import { auth, db, storage } from './firebase-init.js';
import { 
  doc, 
  getDoc, 
  setDoc, 
  updateDoc, 
  collection, 
  addDoc, 
  getDocs, 
  deleteDoc, 
  query, 
  orderBy, 
  where,
  limit,
  startAfter,
  onSnapshot
} from 'firebase/firestore';
import { 
  ref, 
  uploadBytes, 
  getDownloadURL, 
  deleteObject 
} from 'firebase/storage';

// User Management - matches the Users entity schema
export class UserService {
  static async createUser(userId, userData) {
    try {
      await setDoc(doc(db, 'users', userId), {
        id: userId, // INTEGER Primary Key (using Firebase UID as string)
        name: userData.name || '',
        email: userData.email,
        password: userData.password, // Should be encrypted in production
        address: userData.address || '', // Optional
        phone: userData.phone || '', // Optional
        rewardsPoints: userData.rewardsPoints || 0, // INTEGER
        createdAt: new Date(),
        updatedAt: new Date()
      });
      return true;
    } catch (error) {
      console.error('Error creating user:', error);
      return false;
    }
  }

  static async getUser(userId) {
    try {
      const docSnap = await getDoc(doc(db, 'users', userId));
      if (docSnap.exists()) {
        return { id: docSnap.id, ...docSnap.data() };
      }
      return null;
    } catch (error) {
      console.error('Error getting user:', error);
      return null;
    }
  }

  static async updateUser(userId, updates) {
    try {
      await updateDoc(doc(db, 'users', userId), {
        ...updates,
        updatedAt: new Date()
      });
      return true;
    } catch (error) {
      console.error('Error updating user:', error);
      return false;
    }
  }

  static async updateUserRewardsPoints(userId, points) {
    try {
      const userRef = doc(db, 'users', userId);
      const userSnap = await getDoc(userRef);
      if (userSnap.exists()) {
        const currentPoints = userSnap.data().rewardsPoints || 0;
        await updateDoc(userRef, {
          rewardsPoints: currentPoints + points,
          updatedAt: new Date()
        });
        return true;
      }
      return false;
    } catch (error) {
      console.error('Error updating user rewards points:', error);
      return false;
    }
  }

  static async getUserByEmail(email) {
    try {
      const usersRef = collection(db, 'users');
      const q = query(usersRef, where('email', '==', email));
      const snapshot = await getDocs(q);
      if (!snapshot.empty) {
        const doc = snapshot.docs[0];
        return { id: doc.id, ...doc.data() };
      }
      return null;
    } catch (error) {
      console.error('Error getting user by email:', error);
      return null;
    }
  }
}

// Rewards Management - matches the Rewards entity schema
export class RewardsService {
  static async getRewards() {
    try {
      const rewardsRef = collection(db, 'rewards');
      const snapshot = await getDocs(rewardsRef);
      const rewards = [];
      snapshot.forEach(doc => {
        rewards.push({ id: doc.id, ...doc.data() });
      });
      return rewards;
    } catch (error) {
      console.error('Error getting rewards:', error);
      return [];
    }
  }

  static async createReward(rewardData) {
    try {
      const docRef = await addDoc(collection(db, 'rewards'), {
        id: '', // Will be auto-generated by Firestore
        name: rewardData.name, // STRING
        description: rewardData.description, // STRING
        points: rewardData.points, // INTEGER
        imagePath: rewardData.imagePath, // STRING
        validity: rewardData.validity, // INTEGER
        maxRedemptions: rewardData.maxRedemptions, // INTEGER
        createdAt: new Date()
      });
      return docRef.id;
    } catch (error) {
      console.error('Error creating reward:', error);
      return null;
    }
  }

  static async updateReward(rewardId, updates) {
    try {
      await updateDoc(doc(db, 'rewards', rewardId), {
        ...updates,
        updatedAt: new Date()
      });
      return true;
    } catch (error) {
      console.error('Error updating reward:', error);
      return false;
    }
  }

  static async deleteReward(rewardId) {
    try {
      await deleteDoc(doc(db, 'rewards', rewardId));
      return true;
    } catch (error) {
      console.error('Error deleting reward:', error);
      return false;
    }
  }

  static async getRewardById(rewardId) {
    try {
      const docSnap = await getDoc(doc(db, 'rewards', rewardId));
      if (docSnap.exists()) {
        return { id: docSnap.id, ...docSnap.data() };
      }
      return null;
    } catch (error) {
      console.error('Error getting reward by ID:', error);
      return null;
    }
  }
}

// User Reward Redemptions Management - matches the userRewardRedemptions entity schema
export class UserRewardRedemptionsService {
  static async getUserRedemptions(userId) {
    try {
      const redemptionsRef = collection(db, 'userRewardRedemptions');
      const q = query(redemptionsRef, where('userId', '==', userId), orderBy('redeemAt', 'desc'));
      const snapshot = await getDocs(q);
      const redemptions = [];
      snapshot.forEach(doc => {
        redemptions.push({ id: doc.id, ...doc.data() });
      });
      return redemptions;
    } catch (error) {
      console.error('Error getting user redemptions:', error);
      return [];
    }
  }

  static async redeemReward(userId, rewardId, rewardName, pointsSpent) {
    try {
      // Add redemption record
      await addDoc(collection(db, 'userRewardRedemptions'), {
        id: '', // Will be auto-generated by Firestore
        userId: userId, // STRING (implied foreign key → Users.id)
        rewardId: rewardId, // STRING (implied foreign key → Rewards.id)
        rewardName: rewardName, // STRING
        pointsSpent: pointsSpent.toString(), // STRING
        redeemAt: new Date() // DateTime
      });

      // Update user rewards points
      await UserService.updateUserRewardsPoints(userId, -parseInt(pointsSpent));

      return true;
    } catch (error) {
      console.error('Error redeeming reward:', error);
      return false;
    }
  }

  static async getRedemptionCount(userId, rewardId) {
    try {
      const redemptionsRef = collection(db, 'userRewardRedemptions');
      const q = query(redemptionsRef, where('userId', '==', userId), where('rewardId', '==', rewardId));
      const snapshot = await getDocs(q);
      return snapshot.size;
    } catch (error) {
      console.error('Error getting redemption count:', error);
      return 0;
    }
  }

  static async getRedemptionById(redemptionId) {
    try {
      const docSnap = await getDoc(doc(db, 'userRewardRedemptions', redemptionId));
      if (docSnap.exists()) {
        return { id: docSnap.id, ...docSnap.data() };
      }
      return null;
    } catch (error) {
      console.error('Error getting redemption by ID:', error);
      return null;
    }
  }
}

// Notifications Management - matches the Notifications entity schema
export class NotificationsService {
  static async getUserNotifications(userId) {
    try {
      const notificationsRef = collection(db, 'notifications');
      const q = query(notificationsRef, where('userId', '==', userId), orderBy('date', 'desc'));
      const snapshot = await getDocs(q);
      const notifications = [];
      snapshot.forEach(doc => {
        notifications.push({ id: doc.id, ...doc.data() });
      });
      return notifications;
    } catch (error) {
      console.error('Error getting notifications:', error);
      return [];
    }
  }

  static async createNotification(userId, message) {
    try {
      await addDoc(collection(db, 'notifications'), {
        id: '', // Will be auto-generated by Firestore
        userId: userId, // INTEGER Foreign Key → Users(id)
        date: new Date(), // DATE
        message: message, // String
        isRead: 0 // INTEGER (0 = unread, 1 = read)
      });
      return true;
    } catch (error) {
      console.error('Error creating notification:', error);
      return false;
    }
  }

  static async markNotificationAsRead(notificationId) {
    try {
      await updateDoc(doc(db, 'notifications', notificationId), {
        isRead: 1 // INTEGER (0 = unread, 1 = read)
      });
      return true;
    } catch (error) {
      console.error('Error marking notification as read:', error);
      return false;
    }
  }

  static async getUnreadNotificationsCount(userId) {
    try {
      const notificationsRef = collection(db, 'notifications');
      const q = query(notificationsRef, where('userId', '==', userId), where('isRead', '==', 0));
      const snapshot = await getDocs(q);
      return snapshot.size;
    } catch (error) {
      console.error('Error getting unread notifications count:', error);
      return 0;
    }
  }
}

// Favourites Management - matches the Favorites entity schema
export class FavouritesService {
  static async getUserFavourites(userId) {
    try {
      const favouritesRef = collection(db, 'favourites');
      const q = query(favouritesRef, where('userId', '==', userId));
      const snapshot = await getDocs(q);
      const favourites = [];
      snapshot.forEach(doc => {
        favourites.push({ id: doc.id, ...doc.data() });
      });
      return favourites;
    } catch (error) {
      console.error('Error getting favourites:', error);
      return [];
    }
  }

  static async addToFavourites(userId, itemId) {
    try {
      await addDoc(collection(db, 'favourites'), {
        id: '', // Will be auto-generated by Firestore
        userId: userId, // INTEGER Foreign Key → Users(id)
        itemId: itemId, // INTEGER Foreign Key → MenuItems(id)
        addedAt: new Date()
      });
      return true;
    } catch (error) {
      console.error('Error adding to favourites:', error);
      return false;
    }
  }

  static async removeFromFavourites(favouriteId) {
    try {
      await deleteDoc(doc(db, 'favourites', favouriteId));
      return true;
    } catch (error) {
      console.error('Error removing from favourites:', error);
      return false;
    }
  }

  static async isItemFavourited(userId, itemId) {
    try {
      const favouritesRef = collection(db, 'favourites');
      const q = query(favouritesRef, where('userId', '==', userId), where('itemId', '==', itemId));
      const snapshot = await getDocs(q);
      return !snapshot.empty;
    } catch (error) {
      console.error('Error checking if item is favourited:', error);
      return false;
    }
  }
}

// File Storage Management
export class StorageService {
  static async uploadFile(file, path) {
    try {
      const storageRef = ref(storage, path);
      const snapshot = await uploadBytes(storageRef, file);
      const downloadURL = await getDownloadURL(snapshot.ref);
      return downloadURL;
    } catch (error) {
      console.error('Error uploading file:', error);
      return null;
    }
  }

  static async deleteFile(path) {
    try {
      const storageRef = ref(storage, path);
      await deleteObject(storageRef);
      return true;
    } catch (error) {
      console.error('Error deleting file:', error);
      return false;
    }
  }
}

// Real-time listeners
export class RealtimeService {
  static onUserChange(userId, callback) {
    return onSnapshot(doc(db, 'users', userId), (doc) => {
      if (doc.exists()) {
        callback({ id: doc.id, ...doc.data() });
      } else {
        callback(null);
      }
    });
  }

  static onNotificationsChange(userId, callback) {
    const notificationsRef = collection(db, 'notifications');
    const q = query(notificationsRef, where('userId', '==', userId), orderBy('date', 'desc'));
    return onSnapshot(q, (snapshot) => {
      const notifications = [];
      snapshot.forEach(doc => {
        notifications.push({ id: doc.id, ...doc.data() });
      });
      callback(notifications);
    });
  }

  static onUserRewardsPointsChange(userId, callback) {
    return onSnapshot(doc(db, 'users', userId), (doc) => {
      if (doc.exists()) {
        const data = doc.data();
        callback(data.rewardsPoints || 0);
      } else {
        callback(0);
      }
    });
  }
}
