// import { 
//   doc, 
//   getDoc, 
//   setDoc, 
//   updateDoc, 
//   collection, 
//   addDoc, 
//   getDocs, 
//   deleteDoc, 
//   query, 
//   orderBy, 
//   where,
//   limit,
//   startAfter,
//   onSnapshot
// } from 'firebase/firestore';
// import { 
//   ref, 
//   uploadBytes, 
//   getDownloadURL, 
//   deleteObject 
// } from 'firebase/storage';

// User Management - matches the Users entity schema
class UserService {
  static async createUser(userId, userData) {
    try {
      await firebase.firestore().collection('users').doc(userId).set({
        id: userId, // INTEGER Primary Key (using Firebase UID as string)
        name: userData.name || '',
        email: userData.email,
        password: userData.password, // Should be encrypted in production
        address: userData.address || '', // Optional
        phone: userData.phone || '', // Optional
        rewardsPoints: userData.rewardsPoints || 0, // INTEGER
        createdAt: new Date(),
        updatedAt: new Date()
      });
      return true;
    } catch (error) {
      console.error('Error creating user:', error);
      return false;
    }
  }

  static async getUser(userId) {
    try {
      const docSnap = await firebase.firestore().collection('users').doc(userId).get();
      if (docSnap.exists) {
        return { id: docSnap.id, ...docSnap.data() };
      }
      return null;
    } catch (error) {
      console.error('Error getting user:', error);
      return null;
    }
  }

  static async updateUser(userId, updates) {
    try {
      await firebase.firestore().collection('users').doc(userId).update({
        ...updates,
        updatedAt: new Date()
      });
      return true;
    } catch (error) {
      console.error('Error updating user:', error);
      return false;
    }
  }

  static async updateUserRewardsPoints(userId, points) {
    try {
      const userRef = firebase.firestore().collection('users').doc(userId);
      const userSnap = await userRef.get();
      if (userSnap.exists) {
        const currentPoints = userSnap.data().rewardsPoints || 0;
        await userRef.update({
          rewardsPoints: currentPoints + points,
          updatedAt: new Date()
        });
        return true;
      }
      return false;
    } catch (error) {
      console.error('Error updating user rewards points:', error);
      return false;
    }
  }

  static async updateUserBalance(userId, amount) {
    try {
      const userRef = firebase.firestore().collection('users').doc(userId);
      const userSnap = await userRef.get();
      if (userSnap.exists) {
        const currentBalance = userSnap.data().balance || 0;
        await userRef.update({
          balance: currentBalance + amount,
          updatedAt: new Date()
        });
        return true;
      }
      return false;
    } catch (error) {
      console.error('Error updating user balance:', error);
      return false;
    }
  }

  static async getUserBalance(userId) {
    try {
      const userRef = firebase.firestore().collection('users').doc(userId);
      const userSnap = await userRef.get();
      if (userSnap.exists) {
        return userSnap.data().balance || 0;
      }
      return 0;
    } catch (error) {
      console.error('Error getting user balance:', error);
      return 0;
    }
  }

  static async getUserByEmail(email) {
    try {
      const usersRef = firebase.firestore().collection('users');
      const q = firebase.firestore().collection('users').where('email', '==', email);
      const snapshot = await q.get();
      if (!snapshot.empty) {
        const doc = snapshot.docs[0];
        return { id: doc.id, ...doc.data() };
      }
      return null;
    } catch (error) {
      console.error('Error getting user by email:', error);
      return null;
    }
  }
}

// Rewards Management - matches the Rewards entity schema
class RewardsService {
  static async getRewards() {
    try {
      const rewardsRef = firebase.firestore().collection('rewards');
      const snapshot = await rewardsRef.get();
      const rewards = [];
      snapshot.forEach(doc => {
        rewards.push({ id: doc.id, ...doc.data() });
      });
      return rewards;
    } catch (error) {
      console.error('Error getting rewards:', error);
      return [];
    }
  }

  static async createReward(rewardData) {
    try {
      const docRef = await firebase.firestore().collection('rewards').add({
        id: '', // Will be auto-generated by Firestore
        name: rewardData.name, // STRING
        description: rewardData.description, // STRING
        points: rewardData.points, // INTEGER
        imagePath: rewardData.imagePath, // STRING
        validity: rewardData.validity, // INTEGER
        maxRedemptions: rewardData.maxRedemptions, // INTEGER
        createdAt: new Date()
      });
      return docRef.id;
    } catch (error) {
      console.error('Error creating reward:', error);
      return null;
    }
  }

  static async updateReward(rewardId, updates) {
    try {
      await firebase.firestore().collection('rewards').doc(rewardId).update({
        ...updates,
        updatedAt: new Date()
      });
      return true;
    } catch (error) {
      console.error('Error updating reward:', error);
      return false;
    }
  }

  static async deleteReward(rewardId) {
    try {
      await firebase.firestore().collection('rewards').doc(rewardId).delete();
      return true;
    } catch (error) {
      console.error('Error deleting reward:', error);
      return false;
    }
  }

  static async getRewardById(rewardId) {
    try {
      const docSnap = await firebase.firestore().collection('rewards').doc(rewardId).get();
      if (docSnap.exists) {
        return { id: docSnap.id, ...docSnap.data() };
      }
      return null;
    } catch (error) {
      console.error('Error getting reward by ID:', error);
      return null;
    }
  }
}

// User Reward Redemptions Management - matches the userRewardRedemptions entity schema
class UserRewardRedemptionsService {
  static async getUserRedemptions(userId) {
    try {
      const redemptionsRef = firebase.firestore().collection('userRewardRedemptions');
      const q = firebase.firestore().collection('userRewardRedemptions').where('userId', '==', userId).orderBy('redeemAt', 'desc');
      const snapshot = await q.get();
      const redemptions = [];
      snapshot.forEach(doc => {
        redemptions.push({ id: doc.id, ...doc.data() });
      });
      return redemptions;
    } catch (error) {
      console.error('Error getting user redemptions:', error);
      return [];
    }
  }

  static async redeemReward(userId, rewardId, rewardName, pointsSpent) {
    try {
      // Add redemption record
      await firebase.firestore().collection('userRewardRedemptions').add({
        id: '', // Will be auto-generated by Firestore
        userId: userId, // STRING (implied foreign key → Users.id)
        rewardId: rewardId, // STRING (implied foreign key → Rewards.id)
        rewardName: rewardName, // STRING
        pointsSpent: pointsSpent.toString(), // STRING
        redeemAt: new Date() // DateTime
      });

      // Update user rewards points
      await UserService.updateUserRewardsPoints(userId, -parseInt(pointsSpent));

      return true;
    } catch (error) {
      console.error('Error redeeming reward:', error);
      return false;
    }
  }

  static async getRedemptionCount(userId, rewardId) {
    try {
      const redemptionsRef = firebase.firestore().collection('userRewardRedemptions');
      const q = firebase.firestore().collection('userRewardRedemptions').where('userId', '==', userId).where('rewardId', '==', rewardId);
      const snapshot = await q.get();
      return snapshot.size;
    } catch (error) {
      console.error('Error getting redemption count:', error);
      return 0;
    }
  }

  static async getRedemptionById(redemptionId) {
    try {
      const docSnap = await firebase.firestore().collection('userRewardRedemptions').doc(redemptionId).get();
      if (docSnap.exists) {
        return { id: docSnap.id, ...docSnap.data() };
      }
      return null;
    } catch (error) {
      console.error('Error getting redemption by ID:', error);
      return null;
    }
  }
}

// Notifications Management - per-user subcollection version
class NotificationsService {
  // Get all notifications for a user
  static async getUserNotifications(userId) {
    try {
      const snapshot = await firebase.firestore()
        .collection('users').doc(userId)
        .collection('notifications')
        .orderBy('date', 'desc')
        .get();
      const notifications = [];
      snapshot.forEach(doc => {
        notifications.push({ id: doc.id, ...doc.data() });
      });
      return notifications;
    } catch (error) {
      console.error('Error getting notifications:', error);
      return [];
    }
  }

  // Create a notification for a user
  static async createNotification(userId, message, title = '') {
    try {
      await firebase.firestore()
        .collection('users').doc(userId)
        .collection('notifications')
        .add({
          date: new Date(),
          message: message,
          title: title,
          isRead: 0 // 0 = unread, 1 = read
        });
      return true;
    } catch (error) {
      console.error('Error creating notification:', error);
      return false;
    }
  }

  // Mark a notification as read
  static async markNotificationAsRead(userId, notificationId) {
    try {
      await firebase.firestore()
        .collection('users').doc(userId)
        .collection('notifications').doc(notificationId)
        .update({
          isRead: 1
        });
      return true;
    } catch (error) {
      console.error('Error marking notification as read:', error);
      return false;
    }
  }

  // Get unread notifications count
  static async getUnreadNotificationsCount(userId) {
    try {
      const snapshot = await firebase.firestore()
        .collection('users').doc(userId)
        .collection('notifications')
        .where('isRead', '==', 0)
        .get();
      return snapshot.size;
    } catch (error) {
      console.error('Error getting unread notifications count:', error);
      return 0;
    }
  }
}

// Favourites Management - per-user subcollection version
class FavouritesService {
  // Get all favourites for a user
  static async getUserFavourites(userId) {
    try {
      const snapshot = await firebase.firestore()
        .collection('users').doc(userId)
        .collection('favourites').get();
      const favourites = [];
      snapshot.forEach(doc => {
        favourites.push({ id: doc.id, ...doc.data() });
      });
      return favourites;
    } catch (error) {
      console.error('Error getting favourites:', error);
      return [];
    }
  }

  // Add a food to user's favourites
  static async addToFavourites(userId, itemId) {
    try {
      // Save full food info for display
      const food = window.menuItems ? window.menuItems[itemId] : null;
      await firebase.firestore()
        .collection('users').doc(userId)
        .collection('favourites').doc(itemId)
        .set({
          itemId: itemId,
          name: food ? food.name : itemId,
          image: food ? food.image : '',
          price: food ? food.price : '',
          addedAt: new Date()
        });
      return true;
    } catch (error) {
      console.error('Error adding to favourites:', error);
      return false;
    }
  }

  // Remove a food from user's favourites
  static async removeFromFavourites(userId, itemId) {
    try {
      await firebase.firestore()
        .collection('users').doc(userId)
        .collection('favourites').doc(itemId)
        .delete();
      return true;
    } catch (error) {
      console.error('Error removing from favourites:', error);
      return false;
    }
  }

  // Check if a food is favourited
  static async isItemFavourited(userId, itemId) {
    try {
      const doc = await firebase.firestore()
        .collection('users').doc(userId)
        .collection('favourites').doc(itemId)
        .get();
      return doc.exists;
    } catch (error) {
      console.error('Error checking if item is favourited:', error);
      return false;
    }
  }
}

// File Storage Management
class StorageService {
  static async uploadFile(file, path) {
    try {
      const storageRef = firebase.storage().ref(path);
      const snapshot = await firebase.storage().uploadBytes(storageRef, file);
      const downloadURL = await firebase.storage().getDownloadURL(snapshot.ref);
      return downloadURL;
    } catch (error) {
      console.error('Error uploading file:', error);
      return null;
    }
  }

  static async deleteFile(path) {
    try {
      const storageRef = firebase.storage().ref(path);
      await firebase.storage().deleteObject(storageRef);
      return true;
    } catch (error) {
      console.error('Error deleting file:', error);
      return false;
    }
  }
}

// Real-time listeners
class RealtimeService {
  static onUserChange(userId, callback) {
    return firebase.firestore().collection('users').doc(userId).onSnapshot((doc) => {
      if (doc.exists) {
        callback({ id: doc.id, ...doc.data() });
      } else {
        callback(null);
      }
    });
  }

  static onNotificationsChange(userId, callback) {
    const notificationsRef = firebase.firestore().collection('notifications');
    const q = firebase.firestore().collection('notifications').where('userId', '==', userId).orderBy('date', 'desc');
    return q.onSnapshot((snapshot) => {
      const notifications = [];
      snapshot.forEach(doc => {
        notifications.push({ id: doc.id, ...doc.data() });
      });
      callback(notifications);
    });
  }

  static onUserRewardsPointsChange(userId, callback) {
    return firebase.firestore().collection('users').doc(userId).onSnapshot((doc) => {
      if (doc.exists) {
        const data = doc.data();
        callback(data.rewardsPoints || 0);
      } else {
        callback(0);
      }
    });
  }
}

// Order Management
class OrderService {
  /**
   * Create a new order in the 'orders' collection.
   * @param {Object} orderData - The order data object (see checkout-page.js for structure)
   * @returns {Promise<string|false>} The new order's document ID, or false on error
   */
  static async createOrder(orderData) {
    try {
      const docRef = await firebase.firestore().collection('orders').add({
        ...orderData,
        createdAt: new Date()
      });
      return docRef.id;
    } catch (error) {
      console.error('Error creating order:', error);
      return false;
    }
  }
}

// Make all services globally available
window.UserService = UserService;
window.RewardsService = RewardsService;
window.UserRewardRedemptionsService = UserRewardRedemptionsService;
window.NotificationsService = NotificationsService;
window.FavouritesService = FavouritesService;
window.StorageService = StorageService;
window.RealtimeService = RealtimeService;
window.OrderService = OrderService;
